<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FPG Live Tracker</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .fade-enter { opacity: 0; transform: translateY(6px); }
    .fade-enter-active { opacity: 1; transform: translateY(0); transition: opacity 160ms ease, transform 160ms ease; }
    .tab-active { border-bottom: 2px solid #14532d; color: #14532d; font-weight: 700; }
    .stroke-dot { font-weight: 700; line-height: 1; }
    .num-btn { @apply rounded-md px-3 py-2 border border-gray-300 hover:bg-gray-50 text-sm; }
    .num-btn.active { background: #14532d; color: #fff; border-color: #14532d; }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">

  <!-- Header -->
  <header class="sticky top-0 z-10 bg-white shadow-sm">
    <div class="max-w-xl mx-auto px-4 py-3">
      <div class="text-center">
        <h1 id="courseName" class="text-xl font-bold text-gray-900"></h1>
        <p class="text-sm text-gray-600 mt-1">
          <span id="groupLine">Group —</span>
          •
          <span id="frontBadge" class="ml-1 px-2 py-0.5 rounded-full text-xs bg-yellow-100 text-yellow-800">Front 9 ⏳</span>
          <span id="backBadge" class="ml-1 px-2 py-0.5 rounded-full text-xs bg-yellow-100 text-yellow-800">Back 9 ⏳</span>
        </p>
      </div>
    </div>
  </header>

  <!-- Hole Bar -->
  <section class="max-w-xl mx-auto px-4 mt-3">
    <div id="holeBar" class="bg-white shadow-sm rounded-lg p-3 flex items-center justify-between">
      <div>
        <div class="text-xs text-gray-500">Hole</div>
        <div id="holeNum" class="text-lg font-semibold text-gray-900">1</div>
      </div>
      <div class="text-center">
        <div class="text-xs text-gray-500">Par</div>
        <div id="holePar" class="text-lg font-semibold text-gray-900">4</div>
      </div>
      <div class="text-right">
        <div class="text-xs text-gray-500">Stroke Index</div>
        <div id="holeHcp" class="text-lg font-semibold text-gray-900">11</div>
      </div>
    </div>
  </section>

  <!-- Players Grid -->
  <main class="max-w-xl mx-auto px-4 mt-3">
    <div id="playersWrap" class="space-y-3"></div>
  </main>

  <!-- Bottom Controls -->
  <footer class="max-w-xl mx-auto px-4 py-3 mt-4">
    <div class="bg-white rounded-lg shadow-sm p-3">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-2">
          <button id="prevHole" class="px-3 py-2 text-sm rounded-md border border-gray-300 hover:bg-gray-50">← Prev</button>
          <button id="nextHole" class="px-3 py-2 text-sm rounded-md border border-gray-300 hover:bg-gray-50">Next →</button>
        </div>
        <div class="flex items-center gap-2">
          <button id="tabFront" class="px-3 py-2 text-sm rounded-md">Front 1–9</button>
          <button id="tabBack" class="px-3 py-2 text-sm rounded-md">Back 10–18</button>
        </div>
      </div>

      <!-- Verify row -->
      <div class="mt-3 border-t pt-3 flex items-center justify-between">
        <div class="text-xs text-gray-500">Verification (two keepers required)</div>
        <div class="flex items-center gap-2">
          <button id="verifyFrontBtn" class="px-3 py-1.5 text-xs rounded-md border border-gray-300 hover:bg-gray-50">Verify Front 9</button>
          <button id="verifyBackBtn" class="px-3 py-1.5 text-xs rounded-md border border-gray-300 hover:bg-gray-50">Verify Back 9</button>
        </div>
      </div>
    </div>
  </footer>

  <script>
    // ======= CONFIG / CONSTANTS =======
    const BIN_ID = '68f6557dae596e708f1f69d1';
    const BIN_LATEST_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}/latest`;
    const BIN_WRITE_URL  = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
    // If your bin requires a key for PUTs, fill it in here:
    const JSONBIN_KEY = '$2a$10$NobB0NeF0o78h06FV0yiWubOB.p9XJhQukdsylN3XYdts3wLQQ6.O';

    // ======= STATE FROM START SCREEN =======
    const selectedCourse = JSON.parse(localStorage.getItem('selectedCourse')); // full course object from pairings
    const selectedGroupIndex = parseInt(localStorage.getItem('selectedGroup'), 10);
    const isScorekeeper = JSON.parse(localStorage.getItem('isScorekeeper'));
    if (!selectedCourse || Number.isNaN(selectedGroupIndex)) {
      alert('Missing setup info. Please start from the index page.');
      window.location.href = 'index.html';
    }

    // Ask name (used to tag keeper entries)
    let keeperName = localStorage.getItem('keeperName') || '';
    async function ensureKeeperName() {
      if (keeperName && keeperName.trim()) return;
      const guess = (selectedCourse.groups?.[selectedGroupIndex]?.scorekeeper1) || '';
      const input = prompt('Enter your name (for verification)', guess);
      keeperName = (input || 'Keeper').trim();
      localStorage.setItem('keeperName', keeperName);
    }

    // ======= DERIVED STATE =======
    const group = selectedCourse.groups[selectedGroupIndex];
    const courseName = selectedCourse.course_name;
    const groupKey = `group${group.group_number}`;
    const players = group.players || []; // [{name, handicap}]
    // “handicap” here means strokes given for the day (we cap at 18)
    const strokesGiven = (p) => Math.max(0, Math.min(18, Number(p.handicap || 0)));

    // UI refs
    const courseNameEl = document.getElementById('courseName');
    const groupLineEl = document.getElementById('groupLine');
    const frontBadgeEl = document.getElementById('frontBadge');
    const backBadgeEl  = document.getElementById('backBadge');
    const holeNumEl = document.getElementById('holeNum');
    const holeParEl = document.getElementById('holePar');
    const holeHcpEl = document.getElementById('holeHcp');
    const playersWrap = document.getElementById('playersWrap');

    const prevHoleBtn = document.getElementById('prevHole');
    const nextHoleBtn = document.getElementById('nextHole');
    const tabFrontBtn = document.getElementById('tabFront');
    const tabBackBtn = document.getElementById('tabBack');
    const verifyFrontBtn = document.getElementById('verifyFrontBtn');
    const verifyBackBtn  = document.getElementById('verifyBackBtn');

    // holeIndex: 0..17
    let holeIndex = 0;
    let frontVerifiedBy = new Set(); // names who verified front
    let backVerifiedBy  = new Set(); // names who verified back

    // Hole data map (par/hcp) fetched from BIN "courses" object
    let courseHoles = []; // [{par, hcp}] length 18

    // Local cache of scores we read from Bin
    let binData = null;

    // ======= HELPERS =======
    function isFront() { return holeIndex < 9; }
    function clampHole(i) { return Math.max(0, Math.min(17, i)); }
    function fadeIn(el) {
      el.classList.add('fade-enter');
      requestAnimationFrame(() => {
        el.classList.add('fade-enter-active');
        setTimeout(() => {
          el.classList.remove('fade-enter', 'fade-enter-active');
        }, 180);
      });
    }

    // Allocate a stroke on holes whose stroke index <= strokesGiven
    function getsStrokeOnHole(player, holeIdx) {
      const h = strokesGiven(player);
      if (!courseHoles[holeIdx]) return false;
      const si = Number(courseHoles[holeIdx].hcp);
      return h > 0 && si <= h;
    }

    // Stableford (net = gross - (stroke?1:0))
    function stablefordPoints(gross, par, strokeApplied) {
      if (!gross || !par) return 0;
      const net = gross - (strokeApplied ? 1 : 0);
      const diff = net - par;
      if (diff <= -3) return 5; // albatross+
      if (diff === -2) return 4; // eagle
      if (diff === -1) return 3; // birdie
      if (diff === 0)  return 2; // par
      if (diff === 1)  return 1; // bogey
      return 0;                  // double+
    }

    function holeKey(n) { return `hole${n}`; } // 1..18

    // ======= RENDER =======
    function updateHeaderBadges() {
      // Both keepers must verify per side to flip to ✅
      const frontDone = (binData?.verifications?.[groupKey]?.front) || {};
      const backDone  = (binData?.verifications?.[groupKey]?.back)  || {};

      const frontKeepers = Object.keys(frontDone).filter(k => frontDone[k] === true);
      const backKeepers  = Object.keys(backDone).filter(k => backDone[k] === true);

      const frontOk = frontKeepers.length >= 2;
      const backOk  = backKeepers.length >= 2;

      frontBadgeEl.textContent = frontOk ? 'Front 9 ✅' : 'Front 9 ⏳';
      frontBadgeEl.className = frontOk
        ? 'ml-1 px-2 py-0.5 rounded-full text-xs bg-green-100 text-green-800'
        : 'ml-1 px-2 py-0.5 rounded-full text-xs bg-yellow-100 text-yellow-800';

      backBadgeEl.textContent = backOk ? 'Back 9 ✅' : 'Back 9 ⏳';
      backBadgeEl.className = backOk
        ? 'ml-1 px-2 py-0.5 rounded-full text-xs bg-green-100 text-green-800'
        : 'ml-1 px-2 py-0.5 rounded-full text-xs bg-yellow-100 text-yellow-800';
    }

    function renderHoleBar() {
      const hData = courseHoles[holeIndex] || { par: '-', hcp: '-' };
      holeNumEl.textContent = (holeIndex + 1);
      holeParEl.textContent = hData.par;
      holeHcpEl.textContent = hData.hcp;
      fadeIn(document.getElementById('holeBar'));
    }

    function renderPlayers() {
      playersWrap.innerHTML = '';
      const hData = courseHoles[holeIndex] || { par: null, hcp: null };
      const par = Number(hData.par || 0);

      // Existing scores for this hole
      const scoresRoot = binData?.scores?.[groupKey]?.[holeKey(holeIndex + 1)] || {};

      players.forEach((p, idx) => {
        const strokeApplies = getsStrokeOnHole(p, holeIndex);
        const dot = strokeApplies ? '<span class="stroke-dot" aria-hidden="true">•</span>' : '';
        const hcap = strokesGiven(p);

        // Determine the "current" gross score we show for this player (prefer consensus if exists,
        // otherwise show this keeper's entry if present)
        const playerNode = scoresRoot[p.name] || {};
        const keeperGross = playerNode[keeperName]?.score || null;

        const card = document.createElement('div');
        card.className = 'bg-white rounded-lg shadow-sm p-3 fade-enter';

        card.innerHTML = `
          <div class="flex items-start justify-between">
            <div>
              <div class="font-semibold text-gray-900">${p.name}</div>
              <div class="text-xs text-gray-500">Handicap: ${hcap}</div>
            </div>
            <div class="text-sm text-gray-600">${dot}</div>
          </div>

          <div class="mt-2 flex items-center justify-between">
            <div class="text-xs text-gray-500">Enter score</div>
            <div class="text-xs text-gray-500">Stableford: <span id="pts-${idx}" class="font-semibold">—</span></div>
          </div>

          <div class="mt-2 grid grid-cols-10 gap-1">
            ${Array.from({length: 10}, (_,i) => i+1).map(n => `
              <button data-player-idx="${idx}" data-score="${n}"
                class="num-btn ${keeperGross===n ? 'active':''}">${n}</button>
            `).join('')}
          </div>
        `;

        playersWrap.appendChild(card);

        // compute initial points display
        if (keeperGross) {
          const pts = stablefordPoints(keeperGross, par, strokeApplies);
          card.querySelector(`#pts-${idx}`).textContent = pts;
        }
        requestAnimationFrame(() => card.classList.add('fade-enter-active'));
        setTimeout(() => card.classList.remove('fade-enter','fade-enter-active'), 180);
      });

      // Attach click handlers
      playersWrap.querySelectorAll('button.num-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const idx = Number(e.currentTarget.dataset.playerIdx);
          const score = Number(e.currentTarget.dataset.score);
          await saveScore(players[idx], score);
          // Refresh visuals
          await refreshFromBin(false);
          renderHoleBar();
          renderPlayers();
        });
      });
    }

    function updateTabUI() {
      if (isFront()) {
        tabFrontBtn.classList.add('tab-active');
        tabBackBtn.classList.remove('tab-active');
      } else {
        tabBackBtn.classList.add('tab-active');
        tabFrontBtn.classList.remove('tab-active');
      }
    }

    // ======= BIN I/O =======
    async function refreshFromBin(firstLoad = false) {
      const res = await fetch(BIN_LATEST_URL, { headers: { 'X-Bin-Meta': 'false' } });
      const data = await res.json();

      // Support multiple wrapping formats:
      // - {record:{...}}, {record:[...]}, [{record:[...]}]
      const root = (data.record?.record) || (data.record?.[0]) || (Array.isArray(data) ? data[0]?.record : data.record) || data;

      // Expect:
      //   root.courses[courseName] -> [{par,hcp} x18]
      //   root.scores[groupKey][holeN][playerName][keeperName] = {score, updatedAt}
      //   root.verifications[groupKey].front[keeperName] = true/false
      //   root.verifications[groupKey].back[keeperName]  = true/false
      binData = root || {};
      courseHoles = (binData.courses?.[courseName]) || [];

      if (firstLoad && courseHoles.length !== 18) {
        console.warn('Course holes missing or not 18; falling back to par/hcp unknown.');
      }
    }

    async function putBin(updatedRoot) {
      await fetch(BIN_WRITE_URL, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          ...(JSONBIN_KEY ? {'X-Master-Key': JSONBIN_KEY} : {})
        },
        body: JSON.stringify([updatedRoot]) // keep array wrapper as you prefer
      });
    }

    async function saveScore(player, grossScore) {
      // Merge our entry into binData, then PUT whole array-wrapped root back
      const now = new Date().toISOString();
      const hk = holeKey(holeIndex + 1);

      // Ensure trees
      binData.scores = binData.scores || {};
      binData.scores[groupKey] = binData.scores[groupKey] || {};
      binData.scores[groupKey][hk] = binData.scores[groupKey][hk] || {};
      binData.scores[groupKey][hk][player.name] = binData.scores[groupKey][hk][player.name] || {};

      binData.scores[groupKey][hk][player.name][keeperName] = {
        score: grossScore,
        updatedAt: now
      };

      await putBin(binData);
    }

    async function verifySide(side /* 'front'|'back' */) {
      binData.verifications = binData.verifications || {};
      binData.verifications[groupKey] = binData.verifications[groupKey] || {};
      binData.verifications[groupKey][side] = binData.verifications[groupKey][side] || {};
      binData.verifications[groupKey][side][keeperName] = true;
      await putBin(binData);
      await refreshFromBin(false);
      updateHeaderBadges();
    }

    // ======= INIT =======
    (async function init() {
      await ensureKeeperName();

      // Header fixed info
      courseNameEl.textContent = courseName;
      groupLineEl.textContent  = `Group ${group.group_number}`;

      // LoadBin → render
      await refreshFromBin(true);
      updateHeaderBadges();
      renderHoleBar();
      renderPlayers();
      updateTabUI();

      // Nav
      prevHoleBtn.addEventListener('click', () => {
        holeIndex = clampHole(holeIndex - 1);
        renderHoleBar(); renderPlayers(); updateTabUI();
      });
      nextHoleBtn.addEventListener('click', () => {
        holeIndex = clampHole(holeIndex + 1);
        renderHoleBar(); renderPlayers(); updateTabUI();
      });

      tabFrontBtn.addEventListener('click', () => {
        holeIndex = 0;
        renderHoleBar(); renderPlayers(); updateTabUI();
      });
      tabBackBtn.addEventListener('click', () => {
        holeIndex = 9;
        renderHoleBar(); renderPlayers(); updateTabUI();
      });

      // Verify buttons — only allow verifying at 9 and 18 (but do NOT gray anything out)
      verifyFrontBtn.addEventListener('click', async () => {
        if (holeIndex <= 8) {
          await verifySide('front');
        } else {
          // allow anytime: comment the next line if you want strictly on hole 9
          await verifySide('front');
        }
      });
      verifyBackBtn.addEventListener('click', async () => {
        if (holeIndex >= 9) {
          await verifySide('back');
        } else {
          // allow anytime: comment the next line if you want strictly on hole 18
          await verifySide('back');
        }
      });

      // Light polling to reflect partner entries while you play (every 6s)
      setInterval(async () => {
        const before = JSON.stringify(binData?.scores?.[groupKey]?.[holeKey(holeIndex+1)] || {});
        await refreshFromBin(false);
        const after = JSON.stringify(binData?.scores?.[groupKey]?.[holeKey(holeIndex+1)] || {});
        if (before !== after) {
          renderPlayers();
        }
        updateHeaderBadges();
      }, 6000);
    })();
  </script>
</body>
</html>
